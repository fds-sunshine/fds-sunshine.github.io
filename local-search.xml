<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>结构型模式-过滤器模式</title>
    <link href="/fds-sunshine.github.io/2022/07/08/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/08/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h1><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种设计模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteraPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/filter_pattern_uml_diagram.jpg"></p><h1 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h1><p>创建一个类，在该类上应用标准。<br>Person.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br> <br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String gender;<br>   <span class="hljs-keyword">private</span> String maritalStatus;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,String gender,String maritalStatus)</span>&#123;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.gender = gender;<br>      <span class="hljs-built_in">this</span>.maritalStatus = maritalStatus;        <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> gender;<br>   &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMaritalStatus</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> maritalStatus;<br>   &#125;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h1><p>为标准（Criteria）创建一个接口。<br>Criteria.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Criteria</span> &#123;<br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h1><p>创建实现了 Criteria 接口的实体类。<br>CriteriaMale.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CriteriaMale</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Criteria</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> &#123;<br>      List&lt;Person&gt; malePersons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;(); <br>      <span class="hljs-keyword">for</span> (Person person : persons) &#123;<br>         <span class="hljs-keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="hljs-string">&quot;MALE&quot;</span>))&#123;<br>            malePersons.add(person);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> malePersons;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>CriteriaFemale.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CriteriaFemale</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Criteria</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> &#123;<br>      List&lt;Person&gt; femalePersons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;(); <br>      <span class="hljs-keyword">for</span> (Person person : persons) &#123;<br>         <span class="hljs-keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="hljs-string">&quot;FEMALE&quot;</span>))&#123;<br>            femalePersons.add(person);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> femalePersons;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>CriteriaSingle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CriteriaSingle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Criteria</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> &#123;<br>      List&lt;Person&gt; singlePersons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;(); <br>      <span class="hljs-keyword">for</span> (Person person : persons) &#123;<br>         <span class="hljs-keyword">if</span>(person.getMaritalStatus().equalsIgnoreCase(<span class="hljs-string">&quot;SINGLE&quot;</span>))&#123;<br>            singlePersons.add(person);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> singlePersons;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AndCriteria.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndCriteria</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Criteria</span> &#123;<br><br>   <span class="hljs-keyword">private</span> Criteria criteria;<br>   <span class="hljs-keyword">private</span> Criteria otherCriteria;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndCriteria</span><span class="hljs-params">(Criteria criteria, Criteria otherCriteria)</span> &#123;<br>      <span class="hljs-built_in">this</span>.criteria = criteria;<br>      <span class="hljs-built_in">this</span>.otherCriteria = otherCriteria; <br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> &#123;<br>      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);      <br>      <span class="hljs-keyword">return</span> otherCriteria.meetCriteria(firstCriteriaPersons);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>OrCriteria.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrCriteria</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Criteria</span> &#123;<br><br>   <span class="hljs-keyword">private</span> Criteria criteria;<br>   <span class="hljs-keyword">private</span> Criteria otherCriteria;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrCriteria</span><span class="hljs-params">(Criteria criteria, Criteria otherCriteria)</span> &#123;<br>      <span class="hljs-built_in">this</span>.criteria = criteria;<br>      <span class="hljs-built_in">this</span>.otherCriteria = otherCriteria; <br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> &#123;<br>      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);<br>      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);<br><br>      <span class="hljs-keyword">for</span> (Person person : otherCriteriaItems) &#123;<br>         <span class="hljs-keyword">if</span>(!firstCriteriaItems.contains(person))&#123;<br>            firstCriteriaItems.add(person);<br>         &#125;<br>      &#125;    <br>      <span class="hljs-keyword">return</span> firstCriteriaItems;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h1><p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。<br>CriteriaPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CriteriaPatternDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Person&gt; persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;();<br><br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Robert&quot;</span>,<span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));<br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Married&quot;</span>));<br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Laura&quot;</span>,<span class="hljs-string">&quot;Female&quot;</span>, <span class="hljs-string">&quot;Married&quot;</span>));<br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Diana&quot;</span>,<span class="hljs-string">&quot;Female&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));<br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mike&quot;</span>,<span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));<br>      persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bobby&quot;</span>,<span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));<br><br>      <span class="hljs-type">Criteria</span> <span class="hljs-variable">male</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CriteriaMale</span>();<br>      <span class="hljs-type">Criteria</span> <span class="hljs-variable">female</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CriteriaFemale</span>();<br>      <span class="hljs-type">Criteria</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CriteriaSingle</span>();<br>      <span class="hljs-type">Criteria</span> <span class="hljs-variable">singleMale</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndCriteria</span>(single, male);<br>      <span class="hljs-type">Criteria</span> <span class="hljs-variable">singleOrFemale</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrCriteria</span>(single, female);<br><br>      System.out.println(<span class="hljs-string">&quot;Males: &quot;</span>);<br>      printPersons(male.meetCriteria(persons));<br><br>      System.out.println(<span class="hljs-string">&quot;\nFemales: &quot;</span>);<br>      printPersons(female.meetCriteria(persons));<br><br>      System.out.println(<span class="hljs-string">&quot;\nSingle Males: &quot;</span>);<br>      printPersons(singleMale.meetCriteria(persons));<br><br>      System.out.println(<span class="hljs-string">&quot;\nSingle Or Females: &quot;</span>);<br>      printPersons(singleOrFemale.meetCriteria(persons));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPersons</span><span class="hljs-params">(List&lt;Person&gt; persons)</span>&#123;<br>      <span class="hljs-keyword">for</span> (Person person : persons) &#123;<br>         System.out.println(<span class="hljs-string">&quot;Person : [ Name : &quot;</span> + person.getName() <br>            +<span class="hljs-string">&quot;, Gender : &quot;</span> + person.getGender() <br>            +<span class="hljs-string">&quot;, Marital Status : &quot;</span> + person.getMaritalStatus()<br>            +<span class="hljs-string">&quot; ]&quot;</span>);<br>      &#125;<br>   &#125;      <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h1><p>验证输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Males: <br>Person : [ Name : Robert, Gender : Male, Marital Status : Single ]<br>Person : [ Name : John, Gender : Male, Marital Status : Married ]<br>Person : [ Name : Mike, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]<br><br>Females: <br>Person : [ Name : Laura, Gender : Female, Marital Status : Married ]<br>Person : [ Name : Diana, Gender : Female, Marital Status : Single ]<br><br>Single Males: <br>Person : [ Name : Robert, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Mike, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]<br><br>Single Or Females: <br>Person : [ Name : Robert, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Diana, Gender : Female, Marital Status : Single ]<br>Person : [ Name : Mike, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]<br>Person : [ Name : Laura, Gender : Female, Marital Status : Married ]<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构性模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构性模式-桥接模式</title>
    <link href="/fds-sunshine.github.io/2022/07/07/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/07/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不用颜色的圆。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸的问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong></p><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。</li><li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li></ol><p><strong>优点：</strong></p><ol><li>抽象和实现的分离。</li><li>优秀的扩展能力。</li><li>实现细节对客户透明。</li></ol><p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong></p><ol><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>对于那些不希望用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li></ol><p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 来画出不同颜色的圆。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/bridge_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建桥接实现接口。<br>DrawAPI.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现了 DrawAPI 接口的实体桥接实现类。<br>RedCircle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: red, radius: &quot;</span><br>            + radius +<span class="hljs-string">&quot;, x: &quot;</span> +x+<span class="hljs-string">&quot;, &quot;</span>+ y +<span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>GreenCircle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: green, radius: &quot;</span><br>            + radius +<span class="hljs-string">&quot;, x: &quot;</span> +x+<span class="hljs-string">&quot;, &quot;</span>+ y +<span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>使用 DrawAPI 接口创建抽象类 Shape。<br>Shape.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">protected</span> DrawAPI drawAPI;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(DrawAPI drawAPI)</span>&#123;<br>        <span class="hljs-built_in">this</span>.drawAPI = drawAPI;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;   <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建实现了 Shape 接口的实体类。<br>Circle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius, DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">super</span>(drawAPI);<br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        drawAPI.drawCircle(radius,x,y);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 Shape 和 DrawAPI 类画出不用颜色的圆。<br>BridgePatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BridgePatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">redCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedCircle</span>());<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">greenCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreenCircle</span>());<br><br>        redCircle.draw();<br>        greenCircle.draw();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Drawing Circle[ color: red, radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">100</span>, <span class="hljs-number">100</span>]<br>Drawing Circle[  color: green, radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">100</span>, <span class="hljs-number">100</span>]<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构性模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构型模式-适配器模式</title>
    <link href="/fds-sunshine.github.io/2022/07/06/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/06/design-pattern/StructuralPattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁，这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高的音频播放器来播放 vlc 和 mp4 文件。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br><strong>主要解决：</strong>主要解决在软件系统中，常常将一些 “现存的对象” 放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong></p><ol><li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口口。</li><li>通过接口转换，将一个类插入另一个类中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口）</li></ol><p><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong></p><ol><li>美国电器 110V，中国电器 220V，就要有一个适配器将 110V 转化成 220V。</li><li>JAVA JDK 1.1 提供了Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。</li><li>在 Linux 上运行 Windows 程序。</li><li>JAVA 中的 jdbc。</li></ol><p><strong>优点：</strong></p><ol><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>增加了类的透明度。</li><li>灵活性好。</li></ol><p><strong>缺点：</strong></p><ol><li>过多的使用使用适配器模式，会让系统非常凌乱，不易整体进行把控。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li><li>由于 JAVA 至多继承一个类，所以至多只能是配一个适配者类，而且目标类必须是抽象类。</li></ol><p><strong>使用场景：</strong>有动机的修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。</p><p>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p><p>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo,我们演示类使用 AudioPlayer 类来播放各种格式。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/adapter_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>为媒体播放器和更高级的媒体播放器创建接口。<br>MediaPlayer.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MediaPlayer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AdvancedMediaPlayer.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建了实现了 AdvancedMediaPlayer 接口的实体类。<br>VlcPlayer.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VlcPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Playing vlc file. Name: &quot;</span>+ fileName);      <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;<br>        <span class="hljs-comment">//什么也不做</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Mp4Player.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mp4Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;<br>        <span class="hljs-comment">//什么也不做</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Playing mp4 file. Name: &quot;</span>+ fileName);        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建了实现了 MediaPlayer 接口的适配器类。<br>MediaAdapter.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MediaPlayer</span> &#123;<br><br>    AdvancedMediaPlayer advancedMusicPlayer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MediaAdapter</span><span class="hljs-params">(String audioType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>)) &#123;<br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VlcPlayer</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>)) &#123;<br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mp4Player</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>)) &#123;<br>            advancedMusicPlayer.playVlc(fileName);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>)) &#123;<br>            advancedMusicPlayer.playMp4(fileName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建实现了 MediaPlayer 接口的实体类。<br>AudioPlayer.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MediaPlayer</span> &#123;<br>    MediaAdapter mediaAdapter;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span> &#123;<br><br>        <span class="hljs-comment">// 播放 mp3 音乐文件的内置支持</span><br>        <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp3&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Playing mp3 file. Name: &quot;</span> + fileName);<br>        &#125;<br>        <span class="hljs-comment">// mediaAdapter 提供了播放其他文件格式的支持</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>) || audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>)) &#123;<br>            mediaAdapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaAdapter</span>(audioType);<br>            mediaAdapter.play(audioType, fileName);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Invalid media. &quot;</span> + audioType + <span class="hljs-string">&quot; format not supported&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 AudioPlayer 来播放不同类型的音频格式。<br>AdapterPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterPatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AudioPlayer</span> <span class="hljs-variable">audioPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AudioPlayer</span>();<br><br>        audioPlayer.play(<span class="hljs-string">&quot;mp3&quot;</span>, <span class="hljs-string">&quot;beyond the horizon.mp3&quot;</span>);<br>        audioPlayer.play(<span class="hljs-string">&quot;mp4&quot;</span>, <span class="hljs-string">&quot;alone.mp4&quot;</span>);<br>        audioPlayer.play(<span class="hljs-string">&quot;vlc&quot;</span>, <span class="hljs-string">&quot;far far away.vlc&quot;</span>);<br>        audioPlayer.play(<span class="hljs-string">&quot;avi&quot;</span>, <span class="hljs-string">&quot;mind me.avi&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>验证输出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Playing mp3 file. Name: beyond the horizon.mp3<br>Playing mp4 file. Name: alone.mp4<br>Playing vlc file. Name: far far away.vlc<br>Invalid media. avi format not supported<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构性模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型模式-原型模式</title>
    <link href="/fds-sunshine.github.io/2022/07/05/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/05/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的新对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。<br><strong>何时使用：</strong></p><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><p><strong>如何解决：</strong>利用已有的一个原型对象，快速的生成和原型对象一样的实例。<br><strong>关键代码：</strong></p><ol><li>实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()， 在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。</li><li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 “易变类” 拥有稳定的接口。</li></ol><p><strong>应用实例：</strong></p><ol><li>细胞分裂。</li><li>JAVA 中的 Object clone() 方法。</li></ol><p><strong>优点：</strong></p><ol><li>性能提高。</li><li>逃避构造函数的约束。</li></ol><p><strong>缺点：</strong></p><ol><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li><li>必须实现 Cloneable 接口。</li><li>逃避构造函数的约束。</li></ol><p><strong>使用场景：</strong></p><ol><li>资源优化场景。</li><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li><li>性能和安全要求的场景。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li><li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</li></ol><blockquote><p>原型模式已经与 Java 融为浑然一体，可以随手拿来使用。</p></blockquote><p><strong>注意事项：</strong>浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypePatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。<br><img src="https://atts.w3cschool.cn/attachments/day_211126/202111260932563405.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个实现了 Clonable 接口的抽象类。<br>Shape.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">protected</span> String type;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            clone = <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建扩展了上面抽象类的实体类。<br>Rectangle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">()</span>&#123;<br>        type = <span class="hljs-string">&quot;Rectangle&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Rectangle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Square.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Square</span><span class="hljs-params">()</span>&#123;<br>        type = <span class="hljs-string">&quot;Square&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Square::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Circle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">()</span>&#123;<br>        type = <span class="hljs-string">&quot;Circle&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Circle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建一个类，从数据库获取实体类，并把它们存储在一个 ConcurrentHashMap 中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeCache</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentHashMap&lt;String, Shape&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, Shape&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String shapeId)</span> &#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">cachedShape</span> <span class="hljs-operator">=</span> map.get(shapeId);<br>        <span class="hljs-keyword">return</span> (Shape) cachedShape.clone();<br>    &#125;<br><br>    <span class="hljs-comment">// 对每种形状都运行数据库查询，并创建该形状</span><br>    <span class="hljs-comment">// map.put(shapeKey, shape);</span><br>    <span class="hljs-comment">// 例如，我们要添加三种形状</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadCache</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>        circle.setId(<span class="hljs-string">&quot;1&quot;</span>);<br>        map.put(circle.getId(), circle);<br><br>        <span class="hljs-type">Square</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        square.setId(<span class="hljs-string">&quot;2&quot;</span>);<br>        map.put(square.getId(), square);<br><br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        rectangle.setId(<span class="hljs-string">&quot;3&quot;</span>);<br>        map.put(rectangle.getId(), rectangle);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。<br>PrototypePatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypePatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ShapeCache.loadCache();<br><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">clonedShape</span> <span class="hljs-operator">=</span> (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape.getType());       <br><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">clonedShape2</span> <span class="hljs-operator">=</span> (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape2.getType());        <br><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">clonedShape3</span> <span class="hljs-operator">=</span> (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape3.getType());        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>验证输出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Shape : Circle<br>Shape : Square<br>Shape : Rectangle<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型模式-建造者模式</title>
    <link href="/fds-sunshine.github.io/2022/07/04/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/04/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类时独立于其他对象的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时面临着 “一个复杂对象” 的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong></p><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的 “套餐”。</li><li>JAVA 中的 StringBuilder。</li></ol><p><strong>优点：</strong></p><ol><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ol><p><strong>缺点：</strong></p><ol><li>产品必须有共同点，范围有限制。</li><li>如内部变化复杂，会有很多的建造类。</li></ol><p><strong>使用场景：</strong></p><ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li></ol><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后了我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/builder_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个表示食物条目和食物包装的接口。<br>Item.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Item</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Packing <span class="hljs-title function_">packing</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>Packing.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Packing</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pack</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现 Packing 接口的实体类。<br>Wrapper.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Packing</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wrapper&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Bottle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Packing</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bottle&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现 Item 接口的抽象类，该类提供了默认的功能。<br>Burger.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Item</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Packing <span class="hljs-title function_">packing</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wrapper</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ColdDrink.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColdDrink</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Item</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Packing <span class="hljs-title function_">packing</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bottle</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建扩展了 Burger 和 ColdDrink 的实体类<br>VegBurger.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VegBurger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Burger</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">25.0f</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Veg Burger&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ChickenBurger.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChickenBurger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Burger</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">50.5f</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Chicken Burger&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Coke.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coke</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ColdDrink</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">30.0f</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Coke&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Pepsi.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pepsi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ColdDrink</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">35.0f</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pepsi&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>创建一个 Meal 类，带有上面定义的 Item 对象。<br>Meal.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meal</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Item&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Item&gt;();  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(Item item)</span>&#123;<br>        items.add(item);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>;<br>        <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>            cost += item.price();<br>        &#125;      <br>        <span class="hljs-keyword">return</span> cost;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showItems</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>            System.out.print(<span class="hljs-string">&quot;Item : &quot;</span>+item.name());<br>            System.out.print(<span class="hljs-string">&quot;, Packing : &quot;</span>+item.packing().pack());<br>            System.out.println(<span class="hljs-string">&quot;, Price : &quot;</span>+item.price());<br>        &#125;     <br>    &#125;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。<br>MealBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MealBuilder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Meal <span class="hljs-title function_">prepareVegMeal</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Meal</span> <span class="hljs-variable">meal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Meal</span>();<br>        meal.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VegBurger</span>());<br>        meal.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Coke</span>());<br>        <span class="hljs-keyword">return</span> meal;<br>    &#125;   <br><br>    <span class="hljs-keyword">public</span> Meal <span class="hljs-title function_">prepareNonVegMeal</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Meal</span> <span class="hljs-variable">meal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Meal</span>();<br>        meal.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChickenBurger</span>());<br>        meal.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pepsi</span>());<br>        <span class="hljs-keyword">return</span> meal;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h2><p>BuilderPatternDemo 使用 MealBuild 来演示建造者模式（Builder Pattern）。<br>BuilderPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BuilderPatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MealBuilder</span> <span class="hljs-variable">mealBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MealBuilder</span>();<br><br>        <span class="hljs-type">Meal</span> <span class="hljs-variable">vegMeal</span> <span class="hljs-operator">=</span> mealBuilder.prepareVegMeal();<br>        System.out.println(<span class="hljs-string">&quot;Veg Meal&quot;</span>);<br>        vegMeal.showItems();<br>        System.out.println(<span class="hljs-string">&quot;Total Cost: &quot;</span> +vegMeal.getCost());<br><br>        <span class="hljs-type">Meal</span> <span class="hljs-variable">nonVegMeal</span> <span class="hljs-operator">=</span> mealBuilder.prepareNonVegMeal();<br>        System.out.println(<span class="hljs-string">&quot;\n\nNon-Veg Meal&quot;</span>);<br>        nonVegMeal.showItems();<br>        System.out.println(<span class="hljs-string">&quot;Total Cost: &quot;</span> +nonVegMeal.getCost());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h2><p>验证输出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Veg Meal<br>Item : Veg Burger, Packing : Wrapper, Price : <span class="hljs-number">25.0</span><br>Item : Coke, Packing : Bottle, Price : <span class="hljs-number">30.0</span><br>Total Cost: <span class="hljs-number">55.0</span><br><br><br>Non-Veg Meal<br>Item : Chicken Burger, Packing : Wrapper, Price : <span class="hljs-number">50.5</span><br>Item : Pepsi, Packing : Bottle, Price : <span class="hljs-number">35.0</span><br>Total Cost: <span class="hljs-number">85.5</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型模式-单例模式</title>
    <link href="/fds-sunshine.github.io/2022/07/04/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/04/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br><strong>注意：</strong></p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>应用实例：</strong></p><ol><li>一个党只能有一个主席。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><p><strong>优点：</strong></p><ol><li>在内存中里只有一个实例，减少内存的开销，尤其是频繁的创建与销毁实例（比如某个网站首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><ol><li>要求产生唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建一个对象需要小号的资源过多，比如 I/O 与数据库的连接等。</li></ol><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized （Singleton.class）防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/singleton_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个 Singleton 类<br>SingleObject.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleObject</span> &#123;<br><br>    <span class="hljs-comment">//创建 SingleObject 的一个对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleObject</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleObject</span>();<br><br>    <span class="hljs-comment">//让构造函数为 private，这样该类就不会被实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleObject</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">//获取唯一可用的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMessage</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>从 SingleObject获取唯一的实例。<br>SingletonPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonPatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//不合法的构造函数</span><br>        <span class="hljs-comment">//编译时错误：构造函数 SingleObject() 是不可见的</span><br>        <span class="hljs-comment">//SingleObject object = new SingleObject();</span><br><br>        <span class="hljs-comment">//获取唯一可用的对象</span><br>        <span class="hljs-type">SingleObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> SingleObject.getInstance();<br><br>        <span class="hljs-comment">//显示消息</span><br>        object.showMessage();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>验证输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Hello World!<br></code></pre></div></td></tr></table></figure><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所有严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h3 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是效率很低，99% 情况下需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;<br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 ClassLoader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4-双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4. 双检锁 / 双重校验锁（DCL，即 double-checked locking）"></a>4. 双检锁 / 双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK 1.5起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5. 登记式 / 静态内部类"></a>5. 登记式 / 静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的境况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 ClassLoader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被类装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 geInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种就显得很合理。<br><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p><strong>JDK 版本：</strong>JDK 1.5起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>是<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK 1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 中懒汉式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型模式-抽象工厂模式</title>
    <link href="/fds-sunshine.github.io/2022/07/02/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/02/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br><br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br><strong>如何解决：</strong>在一个产品族里面，定义多个产品。<br><strong>关键代码：</strong>在一个工厂里聚合多类同类产品。<br><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服，不如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一些列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点：</strong>产品族扩展非常困难，要增加一系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong></p><ol><li>QQ换皮肤，一整套一起换。</li><li>生成不同操作系统的程序。</li></ol><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂都是扩展了AbstractFactory。然后创建一个工厂创造器 / 生成器类 FactoryProducer。</p><p>AbstractFactoryPatternDemo， 我们演示类使用 FactoryPrducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape （CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color （RED / GREEN / BLUE），以便获取它所需对象的类型。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/abstractfactory_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>为形状创建一个接口。<br>Shape.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建 Shape 接口的实现类<br>Rectangle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Rectangle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Square.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Square::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Circle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Circle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>为颜色创建一个接口<br>Color.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Color</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建实现 Color 接口的实现类<br>Red.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Color</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Red::fill() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Green.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Green</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Color</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Green::fill() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Blue.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Color</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Blue::fill() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>为 Color 和 Shape 对象创建抽象类来获取对应工厂。<br>AbstractFactory.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Color <span class="hljs-title function_">getColor</span><span class="hljs-params">(String color)</span>;<br>    <span class="hljs-keyword">abstract</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String shape)</span> ;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>创建扩展了AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。<br>ShapeFactory.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String shapeType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (shapeType == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;CIRCLE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;RECTANGLE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;SQUARE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Color <span class="hljs-title function_">getColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ColorFactory.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String shapeType)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Color <span class="hljs-title function_">getColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-keyword">if</span> (color == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;RED&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Red</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;GREEN&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Green</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;BLUE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blue</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h2><p>创建一个工厂创造器 / 生成器类，通过传递形状或颜色信息来获取工厂。<br>FactoryProducer.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String choice)</span> &#123;<br>        <span class="hljs-keyword">if</span> (choice.equalsIgnoreCase(<span class="hljs-string">&quot;SHAPE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (choice.equalsIgnoreCase(<span class="hljs-string">&quot;COLOR&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorFactory</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h2><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。<br>AbstractFactoryPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryPatternDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 获取形状工厂</span><br>        <span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">shapeFactory</span> <span class="hljs-operator">=</span> FactoryProducer.getFactory(<span class="hljs-string">&quot;SHAPE&quot;</span>);<br><br>        <span class="hljs-comment">// 获取形状为 Circle 的对象</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape1</span> <span class="hljs-operator">=</span> shapeFactory.getShape(<span class="hljs-string">&quot;CIRCLE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Circle 的 draw 方法</span><br>        shape1.draw();<br><br>        <span class="hljs-comment">// 获取形状为 Rectangle 的对象</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape2</span> <span class="hljs-operator">=</span> shapeFactory.getShape(<span class="hljs-string">&quot;RECTANGLE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Rectangle 的 draw 方法</span><br>        shape2.draw();<br><br>        <span class="hljs-comment">// 获取形状为 Square 的对象</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape3</span> <span class="hljs-operator">=</span> shapeFactory.getShape(<span class="hljs-string">&quot;SQUARE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Square 的 draw 方法</span><br>        shape3.draw();<br><br>        <span class="hljs-comment">// 获取颜色工厂</span><br>        <span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">colorFactory</span> <span class="hljs-operator">=</span> FactoryProducer.getFactory(<span class="hljs-string">&quot;COLOR&quot;</span>);<br><br>        <span class="hljs-comment">// 获取颜色为 Red 的对象</span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color1</span> <span class="hljs-operator">=</span> colorFactory.getColor(<span class="hljs-string">&quot;RED&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Red 的 fill 方法</span><br>        color1.fill();<br><br>        <span class="hljs-comment">// 获取颜色为 Green 的对象</span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color2</span> <span class="hljs-operator">=</span> colorFactory.getColor(<span class="hljs-string">&quot;Green&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Green 的 fill 方法</span><br>        color2.fill();<br><br>        <span class="hljs-comment">// 获取颜色为 Blue 的对象</span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color3</span> <span class="hljs-operator">=</span> colorFactory.getColor(<span class="hljs-string">&quot;BLUE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Blue 的 fill 方法</span><br>        color3.fill();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h2><p>验证输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.<br>Inside Red::fill() method.<br>Inside Green::fill() method.<br>Inside Blue::fill() method.<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型模式-工厂模式</title>
    <link href="/fds-sunshine.github.io/2022/07/01/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/fds-sunshine.github.io/2022/07/01/design-pattern/CreationalPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong></p><ol><li>您需要一辆汽车的时候，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li><li>Hibernate 换数据库只需要换方言和驱动就可以。</li></ol><p><strong>优点：</strong></p><ol><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以了。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ol><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><p><strong>使用场景：</strong></p><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="https://atts.w3cschool.cn/attachments/uploads/2014/08/factory_pattern_uml_diagram.jpg"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口。<br>Shape.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。<br>Rectangle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Rectangle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Square.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Square::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Circle.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside Circle::draw() method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建一个工厂，生成基于给定信息的实体类的对象。<br>ShapeFactory.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br>    <span class="hljs-comment">// 使用 getShape 方法获取形状类型的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String shapeType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (shapeType == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;CIRCLE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;RECTANGLE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapeType.equalsIgnoreCase(<span class="hljs-string">&quot;SQUARE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>使用该工厂，通过传递类型信息来获取实体类的对象。<br>FactoryPatternDemo.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryPatternDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取 Circle 的对象，并调用它的 draw 方法</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape1</span> <span class="hljs-operator">=</span> ShapeFactory.getShape(<span class="hljs-string">&quot;CIRCLE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Circle 的 draw 方法</span><br>        shape1.draw();<br><br>        <span class="hljs-comment">// 获取 Rectangle 的对象，并调用它的 draw 方法</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape2</span> <span class="hljs-operator">=</span> ShapeFactory.getShape(<span class="hljs-string">&quot;RECTANGLE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Rectangle 的 draw 方法</span><br>        shape2.draw();<br><br>        <span class="hljs-comment">// 获取 Square 的对象，并调用它的 draw 方法</span><br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape3</span> <span class="hljs-operator">=</span> ShapeFactory.getShape(<span class="hljs-string">&quot;SQUARE&quot;</span>);<br><br>        <span class="hljs-comment">// 调用 Square 的 draw 方法</span><br>        shape3.draw();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>验证输出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式简介</title>
    <link href="/fds-sunshine.github.io/2022/06/30/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <url>/fds-sunshine.github.io/2022/06/30/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的实验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式是代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="什么是-GOF-（四人帮，全拼-Gang-of-Four）"><a href="#什么是-GOF-（四人帮，全拼-Gang-of-Four）" class="headerlink" title="什么是 GOF （四人帮，全拼 Gang of Four）"></a>什么是 GOF （四人帮，全拼 Gang of Four）</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Pattern - Elements of Reusable Object-Oriented Software （中文译名：设计模式 - 可复用的面对对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF （四人帮， 全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面对对象设计原则。</p><ul><li>面对接口编程而不是面对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p><h3 id="1-开发人员的共用平台"><a href="#1-开发人员的共用平台" class="headerlink" title="1. 开发人员的共用平台"></a>1. 开发人员的共用平台</h3><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p><h3 id="2-最佳的实践"><a href="#2-最佳的实践" class="headerlink" title="2. 最佳的实践"></a>2. 最佳的实践</h3><p>设计模式已经经历了很长的一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>根据设计模式的参考书 Design Pattern - Elements of Reusable Object - Oriented Software（中文译名：设计模式 - 可复用的面对对象软件元素）中所提到的，总共有23 种设计模式。这些设计模式可以分为三大类：创建型模式（Creational Patterns)、结构性模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我还会讨论另一种设计模式：J2EE 设计模式。</p><table><thead><tr><th>模式</th><th>描述</th><th>包括</th></tr></thead><tbody><tr><td>创建型模式</td><td>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。 这使得程序在判断针对某个给定实力需要创建哪些对象时更加灵活</td><td>- 工厂模式（Factory Pattern）<br> - 抽象工厂模式（Abstract Factory Pattern）<br> - 单例模式（Singleton Pattern） <br> - 建造者模式（Builder Pattern）<br> -原型模式（Prototype Pattern）</td></tr><tr><td>结构型模式</td><td>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>- 适配器模式（Adapter Pattern） <br> - 桥接模式（Bridge Pattern） <br> - 过滤器模式（Filter 、Criteria Pattern） <br> - 组合模式（Composite Pattern）<br> - 装饰器模式（Decorator Pattern）<br> - 外观模式（Facade Pattern）<br> - 享元模式（Flyweight Pattern） <br> - 代理模式（Proxy Pattern）</td></tr><tr><td>行为型模式</td><td>这些设计模式特别关注对象之间的通信</td><td>- 责任链模式（Chain of Responsibility Pattern） <br> - 命令模式（Command Pattern）<br> - 解释器模式（Interpreter Pattern）<br> - 迭代器模式（Iterator Pattern）<br> - 中介者模式（Mediator Pattern）<br> - 备忘录模式（Memento Pattern）<br> - 观察者模式（Observer Pattern）<br> - 状态模式（State Pattern）<br> - 空对象模式（Null Object Pattern）<br> - 策略模式（Strategy Pattern）<br> - 模板模式（Template Pattern）<br> - 访问者模式（Visitor Pattern）</td></tr><tr><td>J2EE 模式</td><td>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 坚定的</td><td>- MVC 模式（MVC Pattern）<br> - 业务代表模式（Business Delegate Pattern）<br> - 组合实体模式（Composite Entity Pattern）<br> - 数据访问对象模式（Data Acess Object Pattern）<br> - 前端控制器模式（Front Controller Pattern）<br> - 拦截过滤器模式（Intercepting Filter Pattern）<br> - 服务定位器模式（Service Locator Pattern）<br> - 传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="https://atts.w3cschool.cn/attachments/day_211126/202111261752107158.jpg"></p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ol><li><p>开闭原则（Open Close Principle）<br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简而言之，是为了是程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></li><li><p>里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li><li><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p></li><li><p>接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p></li><li><p>迪米特法则，又称最少知道原则（Demeter Principle）<br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p>合成复用原则（Composite Reuse Principle）<br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cschool.cn/">W3Cschool</a></li><li>《设计模式 - 可复用的面向对象软件元素》</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing算法模板-数据结构篇</title>
    <link href="/fds-sunshine.github.io/2022/06/24/acwing/acwing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <url>/fds-sunshine.github.io/2022/06/24/acwing/acwing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>acwing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acwing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing算法模板-基础算法篇</title>
    <link href="/fds-sunshine.github.io/2022/06/21/acwing/acwing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/fds-sunshine.github.io/2022/06/21/acwing/acwing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h3><p>快速排序这里使用的是分治的算法思想，分治算法其核心思想是“分而治之”，其是将一个大问题分解成多个相同模式的小问题，然后递归的求解各个小问题，再将小问题的解合并成大问题的解。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h3><p>归并排序也是采用分治的思想。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-二分"><a href="#3-二分" class="headerlink" title="3. 二分"></a>3. 二分</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 找左边第一个匹配的元素</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 找右边第一个匹配的元素</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br>    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-前缀和、差分（只看二维情况，以为过于简单）"><a href="#4-前缀和、差分（只看二维情况，以为过于简单）" class="headerlink" title="4. 前缀和、差分（只看二维情况，以为过于简单）"></a>4. 前缀和、差分（只看二维情况，以为过于简单）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// (i, j)的前缀和</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        s[i][j] += s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 某个子矩阵的前缀和（x2 &gt; x1, y2 &gt; y1)</span><br>s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment">// 差分主要的思想</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-双指针"><a href="#5-双指针" class="headerlink" title="5. 双指针"></a>5. 双指针</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    s[q[i]] ++ ;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(j, i)) j++;<br>    res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-位运算-待更新"><a href="#6-位运算-待更新" class="headerlink" title="6. 位运算(待更新)"></a>6. 位运算(待更新)</h3><p>x &amp; -x = x &amp; (~x + 1);</p><h3 id="7-离散化-待更新"><a href="#7-离散化-待更新" class="headerlink" title="7. 离散化(待更新)"></a>7. 离散化(待更新)</h3><h3 id="8-区间合并"><a href="#8-区间合并" class="headerlink" title="8. 区间合并"></a>8. 区间合并</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>acwing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acwing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2PC协议与3PC协议</title>
    <link href="/fds-sunshine.github.io/2022/04/02/distributed/concept/2PC%E5%8D%8F%E8%AE%AE%E4%B8%8E3PC%E5%8D%8F%E8%AE%AE/"/>
    <url>/fds-sunshine.github.io/2022/04/02/distributed/concept/2PC%E5%8D%8F%E8%AE%AE%E4%B8%8E3PC%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2PC-与-3PC-的由来"><a href="#1-2PC-与-3PC-的由来" class="headerlink" title="1. 2PC 与 3PC 的由来"></a>1. 2PC 与 3PC 的由来</h1><p>在分布式系统中，每一个机器节点虽然都能够明确地知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个称为 “协调者（Coordinator）”的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为 “参与者（Participant）”。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。基于这个思想，衍生出了二阶段提交（2PC）和三阶段提交（3PC）两种协议。</p><h1 id="2-2PC"><a href="#2-2PC" class="headerlink" title="2. 2PC"></a>2. 2PC</h1><p>2PC, 是 Two-Phase Commit 的缩写，即二阶段提交，是计算机网络尤其是在数据库领域一致性二设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。</p><h2 id="2-1-2PC协议执行过程"><a href="#2-1-2PC协议执行过程" class="headerlink" title="2.1 2PC协议执行过程"></a>2.1 2PC协议执行过程</h2><p>2PC 提交协议是将事务的提交过程分成了两个阶段来进行处理，其执行流程如下：<br><strong>阶段一：提交事务请求：</strong></p><ol><li>事务询问。<br>协调者向所有参与者发送事务内容，询问是否可以事务提交操作，并开始等待各参与者的响应。</li><li>执行事务。<br>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中。</li><li>各参与者向协调者反馈事务询问的响应。<br>如果参与者成功地执行了事务操作，那么久反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者 No 响应，表示事务不可以执行。<br/></li></ol><blockquote><p>上面的内容形式上近似是协调者组织各参与者对一次事务操作的投票表态过程，因此二阶段提交协议的阶段一也被称为 “投票阶段” ，即各参与者投票表明是否要继续执行接下去的事务提交操作。</p></blockquote><p><strong>阶段二：执行事务提交</strong><br>在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能：<br/><br>执行事务提交<br/><br>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务提交。</p><ol><li>发送提交请求。<br>协调者向所有参与者节点发出 Commit 请求。</li><li>事务提交。<br>参与者接收到协调者发送的 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li>反馈事务提交结果。<br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li>完成事务。<br>协调者接收到所有参与者反馈的 Ack 消息后， 完成事务。<br/></li></ol><p>中断事务<br/><br>假如任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li>发送回滚请求。<br>协调者向所有参与者节点发送 Rollback 请求。</li><li>事务回滚。<br>参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果。<br>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li>中断事务。<br>协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断。</li></ol><h2 id="2-2-2PC的优缺点"><a href="#2-2-2PC的优缺点" class="headerlink" title="2.2. 2PC的优缺点"></a>2.2. 2PC的优缺点</h2><h3 id="2-2-1-优点"><a href="#2-2-1-优点" class="headerlink" title="2.2.1 优点"></a>2.2.1 优点</h3><p>二阶段提交协议的优点：原理简单，实现方便。</p><h3 id="2-2-2-缺点"><a href="#2-2-2-缺点" class="headerlink" title="2.2.2 缺点"></a>2.2.2 缺点</h3><p>二阶段提交协议的缺点：同步阻塞、单点问题、脑裂造成数据不一致、过于保守。<br/><br>同步阻塞<br/><br>二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其它任何操作。<br/><br>单点问题<br/><br>在上面的讲解中，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在二阶段中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完事务操作。<br/><br>脑裂造成数据不一致<br/><br>在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送 Commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完 Commit 请求之前自身发送了崩溃，导致最终只有部分参与者收到了 Commit 请求。于是，这部分收到了 Commit 请求的参与者就会进行事务的提交，而其他没没有收到 Commit 请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致的现象。<br/><br>过于保守<br/><br>如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</p><h1 id="3-3PC"><a href="#3-3PC" class="headerlink" title="3. 3PC"></a>3. 3PC</h1><p>上面我们讲解了二阶段提交协议的设计和实现原理，并明确指出了其在实际运行过程中可能存在的诸如同步阻塞、协调者的单点问题、脑裂造成的数据不一致和过于保守的容错机制等缺陷，因此研究者在二阶段提交协议的基础上进行了改进，提出了三阶段提交协议。</p><h2 id="3-1-协议说明"><a href="#3-1-协议说明" class="headerlink" title="3.1 协议说明"></a>3.1 协议说明</h2><p>3PC，是 Three-Phase Commit 的缩写，即三阶段提交，是 2PC 的改进版本，它将二阶段提交协议的”提交事务请求”过程一分为二，新城了由 CanCommit、PreCommit和do Commit三个阶段组成的事务处理协议，下面进行说明：</p><p><strong>阶段一：CanCommit</strong></p><ol><li>事务询问。<br>协调者向所有参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务操作，并开始等待各参与者的响应。</li><li>各参与者向协调者反馈事务询问的响应。<br>参与者在接收到来自协调者的 canCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。</li></ol><p><strong>阶段二：PreCommit</strong><br>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种可能。</p><p><strong>执行事务提交</strong><br>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务预提交。</p><ol><li>发送预提交请求。<br>协调者向所有参与者阶段发出 preCommit 的请求，并进入 Prepared 阶段。</li><li>事务预提交。<br>参与者接收到 PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</li><li>各参与者向协调者反馈事务执行的响应。<br>如果参与者成功执行了事务操作，那么就会反馈给协调者 Ack 响应，同时等待最终的指令：提交（commit）或终止（abort）。</li></ol><p><strong>中断事务</strong><br>假如任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li>发送中断请求。<br>协调者向所有参与者阶段发愁abort请求。</li><li>中断事务。<br>无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中超时，参与者都会中断事务。</li></ol><p><strong>阶段三：doCommit</strong><br>该阶段将进行真正的事务提交，会存在以下两种可能的情况。</p><p><strong>执行请求</strong></p><ol><li>发送提交请求。<br>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的 Ack 响应，那么它将从 “预提交” 状态换到 “提交” 状态，并向所有参与者发送 doCommit 请求。</li><li>事务提交。<br>参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li>反馈事务提交结果。<br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li>完成事务。<br>协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</li></ol><p><strong>中断事务</strong><br>进入这一阶段，假设协调者处于正常工作状态，并且任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li>发送中断请求。<br>协调者向所有的参与者节点发送 abort 请求。</li><li>事务回滚。<br>参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务期间占用的资源。</li><li>反馈事务回滚结果。<br>参与者而在完成事务回滚之后，向协调者发送 Ack 消息。</li><li>中断事务。<br>协调者接收到所有参与者反馈的 Ack 消息后，中断事务。</li></ol><h3 id="3-1-1-可能遇到的问题"><a href="#3-1-1-可能遇到的问题" class="headerlink" title="3.1.1 可能遇到的问题"></a>3.1.1 可能遇到的问题</h3><ul><li>协调者出现问题。</li><li>协调者和参与者之间的网络出现故障。<br>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的 doCommit 或是 abort 请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</li></ul><h3 id="3-1-2-优缺点"><a href="#3-1-2-优缺点" class="headerlink" title="3.1.2 优缺点"></a>3.1.2 优缺点</h3><p><strong>优点：</strong>相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</p><p><strong>缺点：</strong>三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到 preCommit 消息后，如果网路出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致。</p><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><ol><li>《从Paxos到Zookeeper  分布式一致性原理与实践》</li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACID的理解</title>
    <link href="/fds-sunshine.github.io/2022/04/02/distributed/concept/ACID/"/>
    <url>/fds-sunshine.github.io/2022/04/02/distributed/concept/ACID/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是ACID"><a href="#1-什么是ACID" class="headerlink" title="1. 什么是ACID"></a>1. 什么是ACID</h1><p>在说ACID之前我们先了解一个概念，也就是<strong>事务</strong>。<br/><br>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作组成的一个程序执行单元（Unit),狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。<br/></p><p>数据库事务的四个特征也就是ACID，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），所以说，ACID是事务的四大特性。<br/></p><p>下面我们来详细讲解一下ACID：<br><strong>原子性（Atomicity）：</strong>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p><ul><li>全部成功执行。</li><li>全部不执行。<br>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。<br/></li></ul><p><strong>一致性（Consistency）：</strong>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此，当数据库只包含成功事务提交的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。<br/><br><strong>隔离性：</strong>事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。在标准SQL规范中，定义了 4 个事务隔离级别，不同的隔离级别对事务的处理不同，如未授权读、授权读取、可重复读、串行化<br/><br><strong>持久性：</strong>事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须是被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。<br/></p>]]></content>
    
    
    <categories>
      
      <category>分布式基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式的理解</title>
    <link href="/fds-sunshine.github.io/2022/04/02/distributed/concept/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/fds-sunshine.github.io/2022/04/02/distributed/concept/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是分布式"><a href="#1-什么是分布式" class="headerlink" title="1. 什么是分布式"></a>1. 什么是分布式</h1><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p><blockquote><p>上面这个简单的定义涵盖了几乎所有有效地部署了网络化计算机的系统。严格地讲，同一个分布式系统中的计算机在空间部署上是可以随意分布的，这些计算机可能被放在不同的机柜上，也可能在不同的机房中，甚至分布在不同的城市。无论如何，一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有如下的几个特征。</p></blockquote><h2 id="1-1-分布式系统的特征"><a href="#1-1-分布式系统的特征" class="headerlink" title="1.1 分布式系统的特征"></a>1.1 分布式系统的特征</h2><p><strong>分布性：</strong>分布式系统中的多台计算机都会在空间上随意分布，同时，机器的分布情况也会随时变动。<br/><br><strong>对等性：</strong>分布式系统中的计算机没有主/从之分，没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。<br/><br><strong>并发性：</strong>同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等。<br/><br><strong>缺乏全局时钟：</strong>在分布式系统中，很难定义两个时间究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。<br/><br><strong>故障总是发生：</strong>组成分布式系统的所有计算机，都有可能发生任何形式的故障。</p><h2 id="1-2分布式环境的各种问题"><a href="#1-2分布式环境的各种问题" class="headerlink" title="1.2分布式环境的各种问题"></a>1.2分布式环境的各种问题</h2><p><strong>通信异常：</strong>分布式系统需要在各个环节之间进行网络通信，因此每次网络通信都会伴随网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。<br/><br><strong>网络分区：</strong>当分布式节点由于网络异常发生造成只有部分节点能够正常通信——网络分区现象，俗称脑裂。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括数据的事务处理，这就对了分布式一致性提出了非常大的挑战。<br/><br><strong>三态：</strong>即成功、失败、超时。发生超时原因有两个：</p><ul><li>由于网络原因，该请求（消息）并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象。</li><li>该请求（消息）成功的被接收方接收后，并进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。</li></ul><p><strong>节点故障：</strong>宕机或僵死等。<br><br/><br>《未完待续》</p><h1 id="2-参考"><a href="#2-参考" class="headerlink" title="2. 参考"></a>2. 参考</h1><p>1.《从Paxos到Zookeeper  分布式一致性原理与实践》</p>]]></content>
    
    
    <categories>
      
      <category>分布式基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper入门</title>
    <link href="/fds-sunshine.github.io/2022/03/25/distributed/zookeeper/zookeeper%E5%85%A5%E9%97%A8/"/>
    <url>/fds-sunshine.github.io/2022/03/25/distributed/zookeeper/zookeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言<br/></h1><p>在此刻的我并不知道zookeeper是什么，我听到zookeeper的第一感觉就是这家伙是啥啊，对的，前言就这么短，因为我也不知道它是啥，也没怎么用。——2022-03-25 11:09:47</p><h1 id="2-ZooKeeper介绍"><a href="#2-ZooKeeper介绍" class="headerlink" title="2. ZooKeeper介绍"></a>2. ZooKeeper介绍<br/></h1><h2 id="2-1-ZooKeeper名字的由来"><a href="#2-1-ZooKeeper名字的由来" class="headerlink" title="2.1 ZooKeeper名字的由来"></a>2.1 ZooKeeper名字的由来</h2><p>学习一样东西的时候，个人觉得最好是先了解它是怎么出现在人们眼前的，然后出现了之后是怎么慢慢地被人们使用的，使用后怎样被人们慢慢扩展的。<br>这里介绍一下它的由来（摘自《从Paxos到Zookeeper  分布式一致性原理与实践 [倪超著][电子工业出版社]》）：</p><blockquote><p>ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于 “ZooKeeper” 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：”再这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物园命名的分布式组件放在一起，雅虎整个分布式系统看上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调——于是，ZooKeeper的名字也就由此诞生了。</p></blockquote><p>看完ZooKeeper名字的由来是不是有点想笑，传奇的分布式协调框架就由此被命名了，这名字像是不要钱想的一样😂不过也能理解，开发人员都是可爱的😆</p><h2 id="2-2-ZooKeeper概述"><a href="#2-2-ZooKeeper概述" class="headerlink" title="2.2 ZooKeeper概述"></a>2.2 ZooKeeper概述</h2><p>ZooKeeper他是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><blockquote><p>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</p></blockquote><p>ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调、通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>此外，ZooKeeper将数据保存在内存中，性能是非常棒的。在”读”多于”写”的应用程序中尤其地高性能，因为”写”会导致所有的服务器进行数据同步。(“读”多于”写”是协调服务的典型场景)。</p><h2 id="2-3-ZooKeeper特点"><a href="#2-3-ZooKeeper特点" class="headerlink" title="2.3 ZooKeeper特点"></a>2.3 ZooKeeper特点</h2><ul><li><strong>顺序一致性</strong>：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper中去。</li><li><strong>原子性</strong>：所有事务的请求处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功地应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像</strong>：无论客户端连接到哪一个ZooKeeper服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>：任何一次更改请求被应用，更改的结果就会被持久化，知道被下一次更改覆盖。</li></ul><h2 id="2-4-ZooKeeper典型应用场景"><a href="#2-4-ZooKeeper典型应用场景" class="headerlink" title="2.4 ZooKeeper典型应用场景"></a>2.4 ZooKeeper典型应用场景</h2><p>ZooKeeper概述中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>下面选3个典型的应用场景来专门说说(后续更新具体代码逻辑)：</p><ol><li><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放。</li><li><strong>命名服务</strong>：可以通过ZooKeeper的顺序节点生成全局唯一ID。</li><li><strong>数据发布/订阅</strong>：通过Watcher机制可以很方便地实现数据发布/订阅。当你将数据发布到ZooKeeper被监听的节点上，其他机器可通过监听ZooKeeper上的节点的变化来实现配置的动态更新。</li></ol><p>实际上，这些功能的实现基本上都得益于ZooKeeper可以保存数据的功能，但是ZooKeeper不适合保存大量数据，这一点需要注意一下😤</p><h1 id="3-ZooKeeper的功能"><a href="#3-ZooKeeper的功能" class="headerlink" title="3. ZooKeeper的功能"></a>3. ZooKeeper的功能<br/></h1><p>友情提示👿：拿出小本本，下面的内容非常重要啊哈</p><h2 id="3-1-Data-model（数据模型）"><a href="#3-1-Data-model（数据模型）" class="headerlink" title="3.1 Data model（数据模型）"></a>3.1 Data model（数据模型）</h2><p>ZooKeeper数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数字可以说是数字、字符串或者是二进制序列。并且，每个节点还可以拥有N个子节点，最上层是根节点使用”/“来表示。每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最先单元。并且，每个znode都只有一个唯一的路径标识。</p><p>强调一句👿：<strong>ZooKeeper主要是用来协调服务，而不是用来存储业务数据的，所以，不要放比较大的数据在znode上，ZooKeeper给出的上线是每个结点的数据大小最大是1M。</strong></p><p>从下图可以更直观地看出：ZooKeeper节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用”/“进行分割的路径表示，开发人员可以想这个结点中写入数据，也可以在节点下面创建子节点。<br>这些操作后面我们来实操一下。<br><img src="https://javaguide.cn/assets/znode-structure.19119dbd.png"></p><h2 id="3-2-znode（数据节点）"><a href="#3-2-znode（数据节点）" class="headerlink" title="3.2 znode（数据节点）"></a>3.2 znode（数据节点）</h2><p>介绍了ZooKeeper树形数据模型之后，我们知道每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最小单元。你要存放的数据就放在上面，是你使用ZooKeeper过程中经常需要接触到的一个概念。</p><h3 id="3-2-1-znode的4中类型"><a href="#3-2-1-znode的4中类型" class="headerlink" title="3.2.1 znode的4中类型"></a>3.2.1 znode的4中类型</h3><p>一般我们将znode分为4大类：</p><ul><li><strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使ZooKeeper集群宕机，直到将其删除。</li><li><strong>临时（EPHEMERAL）节点</strong>：临时结点的生命周期是与<strong>客户端会话（session）</strong>绑定的，<strong>会话消失则结点消失</strong>。并且<strong>临时结点只能做叶子结点</strong>，不能创建子节点。</li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外，子节点的名称还具有顺序性。比如<code>/node1/00000000001</code>、<code>/node/00000000002</code>。</li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><h3 id="3-2-2-znode数据结构"><a href="#3-2-2-znode数据结构" class="headerlink" title="3.2.2 znode数据结构"></a>3.2.2 znode数据结构</h3><p>每个znode由2部分组成：</p><ul><li><strong>stat</strong>：状态信息。</li><li><strong>data</strong>：节点存放的数据的具体内容。</li></ul><p>如下所示，我通过ZooKeeper的get命令来获取根目录下violet节点的内容。（get命令在下面会详细介绍哟）。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 6] get /violet<br><span class="hljs-comment"># 该数据节点关联的数据内容为空</span><br>null<br><span class="hljs-comment"># 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span><br>cZxid = 0x2<br>ctime = Tue Nov 27 18:05:34 CST 2022<br>mZxid = 0x2<br>mtime = Tue Nov 27 18:05:34 CST 2022<br>pZxid = 0x3<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 0<br>numChildren = 1<br></code></pre></div></td></tr></table></figure><p>Stat类中包含了一个数据节点的所有状态信息的字段，包括事务ID-cZxid、节点创建时间-ctime和子节点个数-numChidren等等。</p><p>下面我们来看一下每个znode状态信息究竟代表的是什么吧！（下面的内容来源于《从Paxos到Zookeeper  分布式一致性原理与实践》，因为松松也不是特别清楚，要学会参考资料哟）：</p><table><thead><tr><th><strong>znode状态信息</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID，即该数据节点被创建时的事务id</td></tr><tr><td>ctime</td><td>create time, 即该节点的创建时间</td></tr><tr><td>mZxid</td><td>modified ZXID，即该节点最终一次更新时的事务id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务id，只有子节点列表变更才会更新pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为0，每更新一次节点内容（不管内容有无变化）该版本号的值增加1</td></tr><tr><td>aclVersion</td><td>节点的ACL版本号，表示该节点ACL信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的sessionid：如果当前节点为持久节点，则ephemeralOwner=0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><h2 id="3-3-版本（version）"><a href="#3-3-版本（version）" class="headerlink" title="3.3 版本（version）"></a>3.3 版本（version）</h2><p>在前面我们已经提到，对应每个znode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个znode的三个相关的版本：</p><ul><li><strong>dataVersion</strong>：当前znode节点的版本号。</li><li><strong>cversion</strong>：当前znode子节点的版本。</li><li><strong>aclVersion</strong>：当前znode的ACL的版本号。</li></ul><h2 id="3-4-ACL（权限控制）"><a href="#3-4-ACL（权限控制）" class="headerlink" title="3.4 ACL（权限控制）"></a>3.4 ACL（权限控制）</h2><p>ZooKeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于UNIX文件系统的权限控制。</p><p>对于znode操作的权限，ZooKeeper提供了以下5种：</p><ul><li><strong>CREATE</strong>：能创建子节点</li><li><strong>READ</strong>：能获取节点数据和列出其子节点</li><li><strong>WRITE</strong>：能设置/更新节点数据</li><li><strong>DELETE</strong>：能删除子节点</li><li><strong>ADMIN</strong>: 能设置节点ACL的权限</li></ul><p>其中尤其需要注意的是， CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><p>对于身份认证，提供了以下几种方式：</p><ul><li><strong>world</strong>：默认方式，所有用户都可无条件访问。</li><li><strong>auth</strong>：不适用任何id，代表任何已认证的用户。</li><li><strong>digest</strong>：用户名：密码认证方式：username:password。</li><li><strong>ip</strong>：对指定ip进行限制。</li></ul><h2 id="3-5-Watcher（事件监听器）"><a href="#3-5-Watcher（事件监听器）" class="headerlink" title="3.5 Watcher（事件监听器）"></a>3.5 Watcher（事件监听器）</h2><p>Watcher（事件监听器），是ZooKeeper中的一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。<br><img src="https://javaguide.cn/assets/watche%E6%9C%BA%E5%88%B6.f523bd89.png"><br>王之怒吼👿：非常有用的一个特性，都拿出小本本记好了，后面用到ZooKeeper基本离不开Watcher（事件监听）机制。</p><h2 id="3-6-会话（Session）"><a href="#3-6-会话（Session）" class="headerlink" title="3.6 会话（Session）"></a>3.6 会话（Session）</h2><p>Session 可以看做是ZooKeeper服务器与客户端之间的一个TCP长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watcher事件通知。</p><p>Session有一个属性叫作：sessionTimeout，sessionTimeout代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话依然有效。</p><p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于sessionID是ZooKeeper会话的一个重要标识，许多与会话相关的运行机制都是基于这个sessionID的，因此，无论是哪台服务器为客户端分配的sessionID，都务必保证全局唯一。</p><h1 id="4-ZooKeeper集群"><a href="#4-ZooKeeper集群" class="headerlink" title="4. ZooKeeper集群"></a>4. ZooKeeper集群</h1><p>为了保证高可用，最好是以集群形态来部署ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么ZooKeeper本身仍然是可用的。通常3台服务器就可以构成一个ZooKeeper集群了。ZooKeeper官方提供的架构图就是一个ZooKeeper集群整体对外提供服务。<br><img src="https://javaguide.cn/assets/zookeeper%E9%9B%86%E7%BE%A4.6fdcc61e.png"><br>上图中每一个Server代表一个安装ZooKeeper服务的服务器。组成ZooKeeper服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都保持着通信。集群间通过ZAB协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p><p><strong>最典型集群模式</strong>：**Master/Slave模式（主备模式）。在这种模式中，通常Master服务器作为主服务器提供写服务，其他的Slave服务器从服务器通过异步复制的方式获取Master服务器最新的数据提供读服务。</p><h3 id="4-1-ZooKeeper集群角色"><a href="#4-1-ZooKeeper集群角色" class="headerlink" title="4.1 ZooKeeper集群角色"></a>4.1 ZooKeeper集群角色</h3><p>但是，在ZooKeeper中没有选择传统的Master/Slave概念，而是引入了Leader、Follower和Observer三种角色。如下图所示<br><img src="https://javaguide.cn/assets/zookeeper%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2.ffff8ef5.png"><br>ZooKeeper集群中的所有机器通过一个Leader<strong>选举过程</strong>来选定一台称为”Leader”的机器，Leader既可以为客户端提供写服务又能提供读服务。除了Leader外，<strong>Follower</strong>和<strong>Observer</strong>都只能提供读服务。Follower和Observer唯一的区别在于Observer机器不参与Leader的选举过程，也不参与写操作的”过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>为客户提供读和写的服务，负责投票的发起和决议，更新系统状态。</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给Leader。参与选举过程中的投票。</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给Leader。不参与选举过程中的投票，也不参与”过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于ZooKeeper3.3系列新增的角色。</td></tr></tbody></table><p>当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入Leader选举过程，这个过程会选举产生新的Leader服务器。</p><p>这个过程大概是这样子的：</p><ol><li>Leader election在（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准leader。</li><li>Discovery（发现阶段）：在这个阶段，followers跟准leader进行通信，同步followers最近接收的事务提议。</li><li>Synchronization（同步阶段）：同步阶段主要是利用leader前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准leader才会成为真正的leader。</li><li>Broadcast（广播阶段）：到了这个阶段，ZooKeeper集群才能正式对外提供事务服务，并且leader可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><h3 id="4-2-ZooKeeper集群中的服务器状态"><a href="#4-2-ZooKeeper集群中的服务器状态" class="headerlink" title="4.2 ZooKeeper集群中的服务器状态"></a>4.2 ZooKeeper集群中的服务器状态</h3><ul><li><strong>LOOKING</strong>：寻找Leader。</li><li><strong>LEADING</strong>：Leader状态，对应的节点为Leader。</li><li><strong>FOLLOWING</strong>：Follower状态，对应的节点为Follower。</li><li><strong>OBSERVING</strong>：Observer状态，对应节点为Observer，该节点不参与Leader选举。</li></ul><h3 id="4-3-ZooKeeper集群为啥最好是奇数台？"><a href="#4-3-ZooKeeper集群为啥最好是奇数台？" class="headerlink" title="4.3 ZooKeeper集群为啥最好是奇数台？"></a>4.3 ZooKeeper集群为啥最好是奇数台？</h3><p>ZooKeeper集群在宕掉几个ZooKeeper服务器之后，如果剩下的ZooKeeper服务器个数大于宕掉的个数的话整个ZooKeeper才依然可用。假如我们的集群中有n台ZooKeeper服务器，那么也就是剩下的服务数必须大于n/2。先说一下结论，2n和2n-1的容忍度是一样的，都是n-1，大家可以先自己仔细想一想。</p><p>比如：假如我们有3台，那么最大允许宕掉1台ZooKeeper服务器，如果我们有4台的的时候也同样只允许宕掉1台。 假如我们有5台，那么最大允许宕掉2台ZooKeeper服务器，如果我们有6台的的时候也同样只允许宕掉2台。</p><p>综上，何必增加那一个不必要的ZooKeeper服务器呢？</p><h3 id="4-4-ZooKeeper选举的过半机制防止脑裂"><a href="#4-4-ZooKeeper选举的过半机制防止脑裂" class="headerlink" title="4.4 ZooKeeper选举的过半机制防止脑裂"></a>4.4 ZooKeeper选举的过半机制防止脑裂</h3><h5 id="何为集群脑裂？"><a href="#何为集群脑裂？" class="headerlink" title="何为集群脑裂？"></a>何为集群脑裂？</h5><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致”脑裂”的情况。</p><p>举例说明：比如现在有一个由6台服务器所组成的一个集群，部署在了2个机房，每个机房3台。正常情况下只有1个leader，但是当两个机房中间网络断开的时候，每个机房的3台服务器都会认为另一个机房的3台服务器下线，而选出自己的leader并对外提供服务。若没有过半机制，当网络恢复的时候会发现有2个leader。仿佛是1个大脑（leader）分散成了2个大脑，这就发生了脑裂现象。脑裂期间2个大脑都可能对外提供服务，这将会带来数据一致性等问题。</p><h5 id="过半机制是如何防止脑裂现象产生的？"><a href="#过半机制是如何防止脑裂现象产生的？" class="headerlink" title="过半机制是如何防止脑裂现象产生的？"></a>过半机制是如何防止脑裂现象产生的？</h5><p>ZooKeeper的过半机制导致不可能产生2个leader，因为少于等于一半是不可能产生leader的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h1 id="5-ZAB协议和Paxos算法"><a href="#5-ZAB协议和Paxos算法" class="headerlink" title="5. ZAB协议和Paxos算法"></a>5. ZAB协议和Paxos算法</h1><p>Paxos算法应该可以说是ZooKeeer的灵魂了。但是，ZooKeeper并没有完全采用Paxos算法，而是使用ZAB协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不想Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法。</p><h3 id="5-1-ZAB协议介绍"><a href="#5-1-ZAB协议介绍" class="headerlink" title="5.1 ZAB协议介绍"></a>5.1 ZAB协议介绍</h3><p>ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><h3 id="5-2-ZAB协议两种基本的模式：崩溃恢复和消息广播"><a href="#5-2-ZAB协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="5.2 ZAB协议两种基本的模式：崩溃恢复和消息广播"></a>5.2 ZAB协议两种基本的模式：崩溃恢复和消息广播</h3><p>ZAB协议包括两种基本的模式，分别是</p><ul><li><strong>崩溃恢复</strong>：当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致</strong>。</li><li><strong>消息广播：当集群中已经有过半的Follwer服务器完成了和Leader服务器的状态同步，name整个服务框架就可以进入消息广播模式了</strong>。当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</li></ul><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ol><li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li><li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li><li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。</li><li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li><li>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。</li><li>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。<h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1></li><li><a href="https://javaguide.cn/">《JavaGuide》——ZooKeeper相关概念总结（入门）</a></li><li>《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》</li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式基础</category>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
